use std :: collections :: HashMap ; use std :: cell :: RefCell ; use std :: rc :: Rc ; # [derive (Debug)] enum TrackElement { Point (Rc < RefCell < track_element :: point :: Point >>) , Signal (Rc < RefCell < track_element :: signal :: Signal >>) } fn main () { let mut track_elements = HashMap :: new () ; track_elements . insert ("F" , TrackElement :: Signal (Rc :: new (RefCell :: new (track_element :: signal :: Signal :: new (track_element :: signal :: SignalState :: default () , track_element :: signal :: SignalType :: ToDo , "F" . to_owned ()))))) ; track_elements . insert ("E" , TrackElement :: Point (Rc :: new (RefCell :: new (track_element :: point :: Point :: new (track_element :: point :: PointState :: default () , "E" . to_owned ()))))) ; track_elements . insert ("A" , TrackElement :: Signal (Rc :: new (RefCell :: new (track_element :: signal :: Signal :: new (track_element :: signal :: SignalState :: default () , track_element :: signal :: SignalType :: ToDo , "A" . to_owned ()))))) ; track_elements . insert ("H" , TrackElement :: Signal (Rc :: new (RefCell :: new (track_element :: signal :: Signal :: new (track_element :: signal :: SignalState :: default () , track_element :: signal :: SignalType :: ToDo , "H" . to_owned ()))))) ; track_elements . insert ("B" , TrackElement :: Point (Rc :: new (RefCell :: new (track_element :: point :: Point :: new (track_element :: point :: PointState :: default () , "B" . to_owned ()))))) ; track_elements . insert ("C" , TrackElement :: Signal (Rc :: new (RefCell :: new (track_element :: signal :: Signal :: new (track_element :: signal :: SignalState :: default () , track_element :: signal :: SignalType :: ToDo , "C" . to_owned ()))))) ; track_elements . insert ("G" , TrackElement :: Signal (Rc :: new (RefCell :: new (track_element :: signal :: Signal :: new (track_element :: signal :: SignalState :: default () , track_element :: signal :: SignalType :: ToDo , "G" . to_owned ()))))) ; track_elements . insert ("D" , TrackElement :: Signal (Rc :: new (RefCell :: new (track_element :: signal :: Signal :: new (track_element :: signal :: SignalState :: default () , track_element :: signal :: SignalType :: ToDo , "D" . to_owned ()))))) ; let mut driveway_manager = track_element :: driveway :: DrivewayManager :: new (HashMap :: new ()) ; let point_states = vec ! [(match track_elements . get ("B") . unwrap () { TrackElement :: Point (p) => p . clone () , _ => unreachable ! () } , track_element :: point :: PointState :: Left)] ; let signal_states = vec ! [(match track_elements . get ("A") . unwrap () { TrackElement :: Signal (s) => s . clone () , _ => unreachable ! () } , track_element :: signal :: SignalState :: Ks1) , (match track_elements . get ("C") . unwrap () { TrackElement :: Signal (s) => s . clone () , _ => unreachable ! () } , track_element :: signal :: SignalState :: Ks1)] ; let target_state = track_element :: driveway :: TargetState :: new (point_states , signal_states) ; driveway_manager . add (Rc :: new (RefCell :: new (track_element :: driveway :: Driveway :: new (vec ! [] , target_state)))) ; let point_states = vec ! [(match track_elements . get ("B") . unwrap () { TrackElement :: Point (p) => p . clone () , _ => unreachable ! () } , track_element :: point :: PointState :: Left)] ; let signal_states = vec ! [(match track_elements . get ("C") . unwrap () { TrackElement :: Signal (s) => s . clone () , _ => unreachable ! () } , track_element :: signal :: SignalState :: Ks1) , (match track_elements . get ("D") . unwrap () { TrackElement :: Signal (s) => s . clone () , _ => unreachable ! () } , track_element :: signal :: SignalState :: Ks1)] ; let target_state = track_element :: driveway :: TargetState :: new (point_states , signal_states) ; driveway_manager . add (Rc :: new (RefCell :: new (track_element :: driveway :: Driveway :: new (vec ! [] , target_state)))) ; let point_states = vec ! [(match track_elements . get ("E") . unwrap () { TrackElement :: Point (p) => p . clone () , _ => unreachable ! () } , track_element :: point :: PointState :: Left)] ; let signal_states = vec ! [(match track_elements . get ("D") . unwrap () { TrackElement :: Signal (s) => s . clone () , _ => unreachable ! () } , track_element :: signal :: SignalState :: Ks1) , (match track_elements . get ("F") . unwrap () { TrackElement :: Signal (s) => s . clone () , _ => unreachable ! () } , track_element :: signal :: SignalState :: Ks1)] ; let target_state = track_element :: driveway :: TargetState :: new (point_states , signal_states) ; driveway_manager . add (Rc :: new (RefCell :: new (track_element :: driveway :: Driveway :: new (vec ! [] , target_state)))) ; let point_states = vec ! [(match track_elements . get ("E") . unwrap () { TrackElement :: Point (p) => p . clone () , _ => unreachable ! () } , track_element :: point :: PointState :: Left)] ; let signal_states = vec ! [(match track_elements . get ("G") . unwrap () { TrackElement :: Signal (s) => s . clone () , _ => unreachable ! () } , track_element :: signal :: SignalState :: Ks1) , (match track_elements . get ("H") . unwrap () { TrackElement :: Signal (s) => s . clone () , _ => unreachable ! () } , track_element :: signal :: SignalState :: Ks1)] ; let target_state = track_element :: driveway :: TargetState :: new (point_states , signal_states) ; driveway_manager . add (Rc :: new (RefCell :: new (track_element :: driveway :: Driveway :: new (vec ! [] , target_state)))) ; driveway_manager . update_conflicting_driveways () ; println ! ("{:?}" , track_elements) ; }